import serial
from serial.tools import list_ports
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure
import time
import threading
import sys
from PyQt5.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout, 
                             QHBoxLayout, QLineEdit, QPushButton, QTextEdit, QLabel)
from PyQt5.QtCore import Qt, pyqtSignal, QObject, QTimer
from PyQt5.QtGui import QFont

BUFFER_SIZE = 10000  # oder ein anderer Wert je nach Bedarf
PLOT_INTERVAL = 300  # in Millisekunden

# Globale Variablen für Threading
timestamps = []
signals = []
running = True
data_lock = threading.Lock()
ser = None

# Signal Emitter für Thread-sichere GUI-Updates
class SignalEmitter(QObject):
    log_signal = pyqtSignal(str)
    plot_signal = pyqtSignal()

emitter = SignalEmitter()

# Funktion, um alle verfügbaren COM-Ports anzuzeigen
def list_serial_ports():
    ports = list_ports.comports()  # Liste der verfügbaren Ports
    if not ports:
        print("Keine seriellen Ports gefunden.")
        return []
    else:
        print("Verfügbare serielle Ports:")
        # Liste der Ports ausgeben
        for i, port in enumerate(ports, 1):  # enumerate mit 1 beginnen für Benutzerfreundlichkeit
            print(f"{i}. {port.device} - {port.description}")
        return ports

# Funktion, um den gewählten Port zu öffnen
def open_serial_port(com_port, baud_rate):
    try:
        ser = serial.Serial(com_port, baud_rate, timeout=1)
        print(f"Verbindung zu {com_port} hergestellt.")
        return ser
    except serial.SerialException as e:
        print(f"Fehler beim Öffnen des Ports {com_port}: {e}")
        return None

# Funktion zum kontinuierlichen Lesen der seriellen Daten
def read_serial_data(ser):
    global timestamps, signals, running
    emitter.log_signal.emit("Serial-Lese-Thread gestartet...")
    
    while running:
        try:
            if ser and ser.is_open:
                line = ser.readline().decode('utf-8').strip()
                
                if line:
                    try:
                        # Versuche, Daten als Zeit und Signal zu parsen
                        time_ns, signal_mv = map(float, line.split(','))
                        
                        with data_lock:
                            timestamps.append(time_ns)
                            signals.append(signal_mv)
                            
                            if len(timestamps) > BUFFER_SIZE:
                                timestamps.pop(0)
                                signals.pop(0)
                        
                        emitter.plot_signal.emit()
                    
                    except ValueError:
                        # Wenn nicht parsbar, als Log-Nachricht ausgeben
                        emitter.log_signal.emit(f"Empfangen: {line}")
                    except Exception as e:
                        emitter.log_signal.emit(f"Fehler beim Verarbeiten: {line} ({e})")
        except Exception as e:
            emitter.log_signal.emit(f"Fehler beim Lesen: {e}")
            break
    
    emitter.log_signal.emit("Serial-Lese-Thread beendet.")

# Befehl an Pico senden
def send_command_to_pico(command):
    global ser
    if ser and ser.is_open:
        try:
            ser.write((command + '\n').encode('utf-8'))
            emitter.log_signal.emit(f">>> Befehl gesendet: {command}")
        except Exception as e:
            emitter.log_signal.emit(f"Fehler beim Senden: {e}")
    else:
        emitter.log_signal.emit("Fehler: Serieller Port nicht geöffnet!")


# PyQt5 GUI-Klasse
class PicoVisualizerApp(QMainWindow):
    def __init__(self, ser_port):
        super().__init__()
        self.ser = ser_port
        self.initUI()
        self.setup_plot_update()
        
    def initUI(self):
        self.setWindowTitle('Pico Pulse Sense - Live Visualizer')
        self.setGeometry(100, 100, 1400, 800)
        
        # Hauptwidget
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        
        # Hauptlayout
        main_layout = QHBoxLayout()
        
        # Linke Seite: Plot
        left_layout = QVBoxLayout()
        
        # Matplotlib-Figure
        self.figure = Figure(figsize=(8, 6), dpi=100)
        self.canvas = FigureCanvas(self.figure)
        self.ax = self.figure.add_subplot(111)
        self.ax.set_title('Live Messdaten')
        self.ax.set_xlabel('Zeit (ns)')
        self.ax.set_ylabel('Signal (mV)')
        self.ax.grid(True, alpha=0.3)
        
        left_layout.addWidget(self.canvas)
        
        # Rechte Seite: Befehle und Logs
        right_layout = QVBoxLayout()
        
        # Log-Bereich
        log_label = QLabel('Log / Empfangene Daten:')
        log_label.setFont(QFont('Arial', 10, QFont.Bold))
        right_layout.addWidget(log_label)
        
        self.log_text = QTextEdit()
        self.log_text.setReadOnly(True)
        self.log_text.setMaximumHeight(400)
        right_layout.addWidget(self.log_text)
        
        # Befehl-Eingabebereich
        cmd_label = QLabel('Befehl an Pico:')
        cmd_label.setFont(QFont('Arial', 10, QFont.Bold))
        right_layout.addWidget(cmd_label)
        
        # Eingabefeld und Button
        cmd_layout = QHBoxLayout()
        self.cmd_input = QLineEdit()
        self.cmd_input.setPlaceholderText('Geben Sie einen Befehl ein und drücken Sie Enter...')
        self.cmd_input.returnPressed.connect(self.send_command)
        cmd_layout.addWidget(self.cmd_input)
        
        send_btn = QPushButton('Senden')
        send_btn.clicked.connect(self.send_command)
        cmd_layout.addWidget(send_btn)
        
        right_layout.addLayout(cmd_layout)
        
        # Vordefinierte Befehle
        predef_label = QLabel('Vordefinierte Befehle:')
        predef_label.setFont(QFont('Arial', 10, QFont.Bold))
        right_layout.addWidget(predef_label)
        
        btn_layout = QVBoxLayout()
        
        btn1 = QPushButton('START')
        btn1.clicked.connect(lambda: self.send_predefined_command('START'))
        btn_layout.addWidget(btn1)
        
        btn2 = QPushButton('STOP')
        btn2.clicked.connect(lambda: self.send_predefined_command('STOP'))
        btn_layout.addWidget(btn2)
        
        btn3 = QPushButton('RESET')
        btn3.clicked.connect(lambda: self.send_predefined_command('RESET'))
        btn_layout.addWidget(btn3)
        
        right_layout.addLayout(btn_layout)
        right_layout.addStretch()
        
        # Layouts zusammensetzen
        main_layout.addLayout(left_layout, 2)
        main_layout.addLayout(right_layout, 1)
        
        central_widget.setLayout(main_layout)
        
        # Signal verbinden
        emitter.log_signal.connect(self.append_log)
        emitter.plot_signal.connect(self.update_plot)
    
    def send_command(self):
        command = self.cmd_input.text().strip()
        if command:
            send_command_to_pico(command)
            self.cmd_input.clear()
    
    def send_predefined_command(self, command):
        send_command_to_pico(command)
    
    def append_log(self, message):
        self.log_text.append(message)
        # Auto-scroll zum Ende
        self.log_text.verticalScrollBar().setValue(
            self.log_text.verticalScrollBar().maximum()
        )
    
    def update_plot(self):
        with data_lock:
            if timestamps and signals:
                self.ax.clear()
                self.ax.plot(timestamps, signals, 'b-', linewidth=1, label='Messwerte')
                self.ax.set_xlabel('Zeit (ns)')
                self.ax.set_ylabel('Signal (mV)')
                self.ax.set_title('Live Messdaten')
                self.ax.grid(True, alpha=0.3)
                self.ax.legend()
                
                if len(timestamps) > 0:
                    self.ax.set_xlim([min(timestamps), max(timestamps)])
                if len(signals) > 0:
                    self.ax.set_ylim([min(signals) - 10, max(signals) + 10])
                
                self.canvas.draw()
    
    def setup_plot_update(self):
        # Timer für regelmäßige Plot-Updates
        self.timer = QTimer()
        self.timer.timeout.connect(self.update_plot)
        self.timer.start(PLOT_INTERVAL)
    
    def closeEvent(self, event):
        global running, ser
        running = False
        time.sleep(0.5)
        if ser and ser.is_open:
            ser.close()
        event.accept()

# Funktion zum Aktualisieren des Plots mit Animation
def update_plot_animation(frame):
    global timestamps, signals
    
    with data_lock:
        if timestamps and signals:
            # Leere den Plot
            ax.clear()
            
            # Zeichne die neuen Daten
            ax.plot(timestamps, signals, 'b-', linewidth=1, label='Messwerte')
            ax.set_xlabel('Zeit (ns)')
            ax.set_ylabel('Signal (mV)')
            ax.set_title('Live Messdaten')
            ax.grid(True, alpha=0.3)
            ax.legend()
            
            # X- und Y-Achse anpassen
            if len(timestamps) > 0:
                ax.set_xlim([min(timestamps), max(timestamps)])
            if len(signals) > 0:
                ax.set_ylim([min(signals) - 10, max(signals) + 10])
            
            print(f"Plot aktualisiert - Datenpunkte: {len(timestamps)}")

# Alle verfügbaren Ports auflisten
ports = list_serial_ports()

com_port = None

if ports:
    # Automatisch nach "Pico" suchen
    for port in ports:
        if "Pico" in port.description:
            com_port = port.device
            print(f"Pico-Port gefunden: {com_port} ({port.description})")
            break
    
    # Falls kein Pico gefunden wurde, Benutzer nach Auswahl fragen
    if com_port is None:
        try:
            choice = int(input("Kein Pico gefunden. Wählen Sie einen Port (1, 2, 3, ...): "))
            if 1 <= choice <= len(ports):
                com_port = ports[choice - 1].device
            else:
                print("Ungültige Auswahl. Bitte wählen Sie eine gültige Nummer.")
        except ValueError:
            print("Ungültige Eingabe. Bitte geben Sie eine Zahl ein.")
    
    # Port öffnen, falls gefunden
    if com_port:
        baud_rate = 115200  # Beispiel-Baudrate
        ser = open_serial_port(com_port, baud_rate)

# Initialisierung der Matplotlib-Figur
fig, ax = plt.subplots(figsize=(12, 6))

# X- und Y-Datenpuffer (bereits oben definiert als globale Variablen)

# Plot-Layout anpassen
ax.set_title('Live Messdaten')
ax.set_xlabel('Zeit (ns)')
ax.set_ylabel('Signal (mV)')
ax.grid(True, alpha=0.3)

# Threads starten
print("Starte Datenerfassung und Plot-Aktualisierung...")
serial_thread = threading.Thread(target=read_serial_data, args=(ser,), daemon=True)
serial_thread.start()

# Matplotlib Animation für Plot-Updates (alle 1000ms = 1 Sekunde)
ani = animation.FuncAnimation(fig, update_plot_animation, interval=plot_interval, blit=False)

# Zeige den Plot
# Hauptprogramm
if __name__ == '__main__':
    # Ports auflisten
    ports = list_serial_ports()
    
    com_port = None
    
    if ports:
        # Automatisch nach "Pico" suchen
        for port in ports:
            if "Pico" in port.description:
                com_port = port.device
                print(f"Pico-Port gefunden: {com_port} ({port.description})")
                break
        
        # Falls kein Pico gefunden wurde, Benutzer fragen
        if com_port is None:
            try:
                choice = int(input("Kein Pico gefunden. Wählen Sie einen Port (1, 2, 3, ...): "))
                if 1 <= choice <= len(ports):
                    com_port = ports[choice - 1].device
                else:
                    print("Ungültige Auswahl.")
                    sys.exit(1)
            except ValueError:
                print("Ungültige Eingabe.")
                sys.exit(1)
        
        # Port öffnen
        baud_rate = 115200
        ser = open_serial_port(com_port, baud_rate)
        
        if ser and ser.is_open:
            # PyQt5 Anwendung starten
            app = QApplication(sys.argv)
            window = PicoVisualizerApp(ser)
            window.show()
            
            # Serial-Lese-Thread starten
            print("Starte Serial-Lese-Thread...")
            serial_thread = threading.Thread(target=read_serial_data, args=(ser,), daemon=True)
            serial_thread.start()
            
            # Anwendung ausführen
            sys.exit(app.exec_())
        else:
            print("Fehler beim Öffnen des seriellen Ports.")
    else:
        print("Keine seriellen Ports gefunden.")
